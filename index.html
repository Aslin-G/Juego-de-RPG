<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RPG Educativo: Llave, Puerta y Murci√©lagos</title>
<style>
  :root{
    --hud-h: 72px;
    --accent: #e1b12c;
    --danger: #e84118;
    --ok: #2ecc71;
    --ink: #111;
    --ink-2: #333;
  }
  *{box-sizing:border-box}
  html, body {
    margin:0; padding:0; background:#ffffff; color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    height:100%;
  }
  #hud{
    position:fixed; top:0; left:0; right:0; height:var(--hud-h); background:rgba(255,255,255,0.95);
    display:flex; align-items:center; gap:18px; padding:10px 16px; border-bottom: 1px solid #eee; z-index:10;
    backdrop-filter: blur(4px);
  }
  #hud .hearts{display:flex; align-items:center; gap:6px; font-size:14px}
  .heart{width:20px; height:20px; border-radius:4px; background:var(--danger); box-shadow: inset 0 -2px 0 rgba(0,0,0,.08);}
  .heart.empty{background:#fff; border:2px solid var(--danger)}
  #timer{font-weight:700; font-variant-numeric: tabular-nums; letter-spacing:1px; padding:6px 10px; background:#fff;
    border:1px solid #eee; border-radius:8px; box-shadow:0 1px 0 #eee;}
  #torchBox{display:flex; align-items:center; gap:10px; width:min(420px, 40vw);}
  #torchBar{position:relative; flex:1; height:16px; border-radius:999px; background:#fafafa; border:1px solid #eee; overflow:hidden;}
  #torchFill{position:absolute; left:0; top:0; bottom:0; width:0%; background:linear-gradient(90deg, #ffd56b, #f39c12);}
  #torchPct{width:54px; text-align:right; font-variant-numeric: tabular-nums; color:var(--ink-2);}
  #hintTorch{font-size:12px; color:#666}
  #audioCtl{margin-left:auto; display:flex; align-items:center; gap:8px; color:#555; font-size:12px}
  #audioCtl input[type="range"]{width:110px}

  #canvasWrap{ position:fixed; left:0; right:0; top:var(--hud-h); bottom:0; overflow:hidden; background:#fff;}
  canvas{ image-rendering: pixelated; background: #f6f8fb; outline:none; display:block; margin:0 auto; }

  /* Modal Preguntas */
  #quizModal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.35); z-index:20;
  }
  #quizCard{
    width:min(760px, 92vw); background:#fff; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.2);
    padding:18px; border:1px solid #eee;
  }
  #quizHdr{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
  #quizHdr h3{margin:0; font-size:18px}
  #qProgress{display:flex; gap:6px}
  .seg{width:18px; height:8px; border-radius:99px; background:#eee}
  .seg.on{background:var(--ok)}
  .seg.bad{background:var(--danger)}
  #qText{font-size:16px; line-height:1.35; margin:8px 0 14px; color:#222}
  .opts{display:grid; grid-template-columns: 1fr; gap:10px}
  .optBtn{
    padding:12px 14px; border:1px solid #ddd; border-radius:12px; background:#fafafa; display:flex; gap:10px; align-items:center;
    cursor:pointer; font-size:15px; transition: transform .05s ease;
  }
  .optBtn:hover{ transform: translateY(-1px); background:#fff; }
  .optKey{ width:28px; height:28px; border-radius:8px; background:#fff; border:1px solid #ddd; display:grid; place-items:center; font-weight:700;}
  .optTxt{flex:1}
  #quizFooter{display:flex; justify-content:space-between; align-items:center; margin-top:10px; color:#666; font-size:12px}

  /* Panel Victoria */
  #victory{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.35); z-index:25;
  }
  #victoryCard{
    width:min(740px, 92vw); background:#fff; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.2);
    padding:18px; border:1px solid #eee;
  }
  table{ border-collapse: collapse; width:100%; font-size:14px; }
  th, td{ border-bottom:1px solid #eee; padding:8px 6px; text-align:left; }
  th{ background:#fafafa }
  .btn{ padding:10px 14px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer; font-weight:600; }
  .btn.primary{ background: var(--accent); border-color:#ca9e28; color:#111 }
  #statusBubble{ font-size:12px; color:#666; }
</style>
</head>
<body>
  <div id="hud" aria-label="Barra superior HUD">
    <div class="hearts" id="hearts"></div>
    <div id="r" aria-live="polite">‚è≥ 07:00</div>
    <div id="torchBox" title="Antorcha (F): 5 s seguro, 60 s recarga">
      <span>üî•</span>
      <div id="torchBar" aria-label="Recarga antorcha"><div id="torchFill"></div></div>
      <div id="torchPct">0%</div>
      <div id="hintTorch">&nbsp;[F]</div>
    </div>
    <div id="statusBubble"></div>
    <div id="audioCtl">
      <label><input type="checkbox" id="mute"> Silencio</label>
      <label>Volumen <input type="range" id="volume" min="0" max="1" step="0.01" value="0.15"></label>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="game" width="1024" height="640" tabindex="0"></canvas>
  </div>

  <!-- Modal Preguntas -->
  <div id="quizModal" role="dialog" aria-modal="true">
    <div id="quizCard">
      <div id="quizHdr">
        <h3>Reto: 7 preguntas</h3>
        <div id="qProgress" aria-label="Progreso preguntas"></div>
      </div>
      <div id="qMeta" style="font-size:12px; color:#666;"></div>
      <div id="qText"></div>
      <div class="opts">
        <button class="optBtn" data-idx="0"><div class="optKey">1</div><div class="optTxt"></div></button>
        <button class="optBtn" data-idx="1"><div class="optKey">2</div><div class="optTxt"></div></button>
        <button class="optBtn" data-idx="2"><div class="optKey">3</div><div class="optTxt"></div></button>
        <button class="optBtn" data-idx="3"><div class="optKey">4</div><div class="optTxt"></div></button>
      </div>
      <div id="quizFooter">
        <div>Usa 1‚Äì4 o clic para responder. <strong>Incorrecta = ‚àí1 ‚ù§Ô∏è</strong></div>
        <div id="quizCount"></div>
      </div>
    </div>
  </div>

  <!-- Panel Victoria / Resultados -->
  <div id="victory">
    <div id="victoryCard">
      <h2 style="margin:6px 0 12px;">¬°Saliste de la mazmorra! üéâ</h2>
      <div id="victStats"></div>
      <h3>Desglose por categor√≠a</h3>
      <table id="catTable">
        <thead><tr><th>Categor√≠a</th><th>Total</th><th>Correctas</th><th>Incorrectas</th><th>Acierto</th></tr></thead>
        <tbody></tbody>
      </table>
      <div style="margin-top:14px; display:flex; gap:8px;">
        <button class="btn primary" id="btnReiniciar">Reiniciar</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   Constantes / Utilidades
========================= */
const TILE = 32;
const ROOM_COLS = 6, ROOM_ROWS = 4;
const ROOM_W = 9, ROOM_H = 7; // interior caminable por sala
const WALL = 1, FLOOR = 0, DOOR = 2, EXIT = 3, KEY = 4;
const MAX_HEARTS = 7;
const TOTAL_TIME = 3*60;
const TORCH_CD = 777, TORCH_SAFE = 7;
const BAT_STEP_MIN = 0.20, BAT_STEP_MAX = 0.30;
const BATS_PER_ROOM = 3; // << puedes cambiarlo
const BAT_WING_PERIOD = 350; // ms
const STATE = { PLAYING:'playing', ASKING:'asking', VICTORY:'victory', DEFEAT_T:'defeat-time', DEFEAT_HP:'defeat-hp' };

// Colores expl√≠citos (no var() para el canvas)
const COLOR_FLOOR_A = '#eef1f6';
const COLOR_FLOOR_B = '#f6f8fb';
const COLOR_WALL    = '#e8ebf0';

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function now(){ return performance.now()/1000; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function fmtTime(sec){ sec=Math.max(0,Math.floor(sec)); const m=String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return m+":"+s; }

/* =========================
   Banco de preguntas (STEM)
   cat ‚àà {Ciencia, Tecnolog√≠a, Ingenier√≠a, Matem√°ticas}
========================= */
const QUESTION_BANK = [
  // Ciencia
  {cat:"Ciencia", text:"¬øCu√°l estructura celular contiene la informaci√≥n gen√©tica principal en c√©lulas eucariotas?", opts:["Mitocondria","Ribosoma","N√∫cleo","Aparato de Golgi"], correct:2},
  {cat:"Ciencia", text:"El agua hierve a menor temperatura en lugares altos porque:", opts:["La presi√≥n atmosf√©rica es menor","El ox√≠geno es mayor","El punto triple cambia","El pH del agua disminuye"], correct:0},
  {cat:"Ciencia", text:"La fotos√≠ntesis convierte energ√≠a:", opts:["Qu√≠mica ‚Üí lum√≠nica","Lum√≠nica ‚Üí qu√≠mica","T√©rmica ‚Üí qu√≠mica","Mec√°nica ‚Üí el√©ctrica"], correct:1},
  {cat:"Ciencia", text:"Un aumento de la temperatura generalmente ______ la solubilidad de un s√≥lido en un l√≠quido.", opts:["disminuye","no cambia","aumenta","invierte"], correct:2},

  // Tecnolog√≠a
  {cat:"Tecnolog√≠a", text:"HTTPS a√±ade al protocolo HTTP principalmente:", opts:["Compresi√≥n","Estado","Cifrado/TLS","Balanceo"], correct:2},
  {cat:"Tecnolog√≠a", text:"Un algoritmo con complejidad O(n log n) es t√≠pico de:", opts:["B√∫squeda lineal","Quicksort/Mergesort","B√∫squeda binaria","Fuerza bruta de contrase√±as"], correct:1},
  {cat:"Tecnolog√≠a", text:"El almacenamiento no vol√°til significa que:", opts:["Pierde datos al apagarse","Requiere energ√≠a continua","Conserva datos sin energ√≠a","Solo existe en RAM"], correct:2},
  {cat:"Tecnolog√≠a", text:"Un ‚Äòcommit‚Äô en control de versiones sirve para:", opts:["Compilar el proyecto","Guardar un punto de cambio con mensaje","Crear un servidor","Instalar dependencias"], correct:1},

  // Ingenier√≠a
  {cat:"Ingenier√≠a", text:"La ley de Ohm se expresa como:", opts:["P=V¬∑I","V=I¬∑R","E=m¬∑c¬≤","F=m¬∑a"], correct:1},
  {cat:"Ingenier√≠a", text:"Para disminuir la resonancia de una estructura, usualmente se:", opts:["Aumenta amortiguamiento","Reduce rigidez","Aumenta la frecuencia natural hacia la excitaci√≥n","Elimina masa"], correct:0},
  {cat:"Ingenier√≠a", text:"Un diagrama de fuerza cortante se usa en:", opts:["Circuits DC","Vigas y flexi√≥n","Termodin√°mica","Transmisi√≥n √≥ptica"], correct:1},
  {cat:"Ingenier√≠a", text:"El factor de seguridad FS se define como:", opts:["Carga √∫ltima / Carga de trabajo","Carga de trabajo / Carga √∫ltima","Esfuerzo admisible / Esfuerzo real","Masa / Volumen"], correct:0},

  // Matem√°ticas
  {cat:"Matem√°ticas", text:"La derivada de f(x)=x¬≤ es:", opts:["2x","x","x¬≥","2"], correct:0},
  {cat:"Matem√°ticas", text:"Si A es el 30% de B, entonces B es:", opts:["0.3¬∑A","3.33¬∑A","A/3.33","A/0.7"], correct:1},
  {cat:"Matem√°ticas", text:"La pendiente de la recta entre (0,3) y (6,15) es:", opts:["1","2","3","4"], correct:1},
  {cat:"Matem√°ticas", text:"La media de 2, 5, 9 y x es 8. Entonces x es:", opts:["12","14","16","18"], correct:2},
];

/* =========================
   Sonido simple
========================= */
const AudioSys = {
  ctx:null, gain:null, musicGain:null,
  ensure(){
    if(!this.ctx){
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.gain = this.ctx.createGain(); this.gain.gain.value = Number(document.getElementById('volume').value);
      this.musicGain = this.ctx.createGain(); this.musicGain.gain.value = 0.07;
      this.gain.connect(this.ctx.destination);
      this.musicGain.connect(this.ctx.destination);
      this.createMusic();
    }
  },
  beep(type='ok'){
    if(!this.ctx || document.getElementById('mute').checked) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = 'sine';
    let f = 880;
    if(type==='ok') f=880;
    else if(type==='bad') f=220;
    else if(type==='key') f=660;
    else if(type==='door') f=520;
    o.frequency.value=f;
    g.gain.value=0.12;
    o.connect(g); g.connect(this.gain);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime+0.18);
    o.stop(this.ctx.currentTime+0.2);
  },
  createMusic(){
    if(!this.ctx) return;
    const ctx=this.ctx;
    function playChord(root=261.63){
      const freqs=[root, root*1.25, root*1.5, root*2];
      freqs.forEach((f,i)=>{
        const o=ctx.createOscillator();
        const g=ctx.createGain();
        o.type='sine'; o.frequency.value=f;
        g.gain.value=0.0001;
        o.connect(g); g.connect(AudioSys.musicGain);
        const t=ctx.currentTime;
        o.start(t+i*0.03);
        g.gain.exponentialRampToValueAtTime(0.06, t+0.5+i*0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, t+4+i*0.03);
        o.stop(t+4.2+i*0.03);
      });
    }
    setInterval(()=>{
      if(document.getElementById('mute').checked) return;
      playChord(261.63); setTimeout(()=>playChord(293.66), 2000);
    }, 4000);
  }
};

/* =========================
   Mapa y salas
========================= */
function buildMap(){
  const totalW = ROOM_COLS*(ROOM_W+1)+1;
  const totalH = ROOM_ROWS*(ROOM_H+1)+1;
  const grid = Array.from({length: totalH}, ()=>Array(totalW).fill(WALL));
  const rooms=[];

  // Interiores
  for(let ry=0; ry<ROOM_ROWS; ry++){
    for(let rx=0; rx<ROOM_COLS; rx++){
      const x1 = rx*(ROOM_W+1)+1;
      const y1 = ry*(ROOM_H+1)+1;
      for(let y=y1; y<y1+ROOM_H; y++)
        for(let x=x1; x<x1+ROOM_W; x++)
          grid[y][x]=FLOOR;
      rooms.push({rx,ry, x1, y1, x2:x1+ROOM_W-1, y2:y1+ROOM_H-1});
    }
  }
  // Aperturas (pasillos)
  for(const r of rooms){
    if(r.rx<ROOM_COLS-1){
      const y = Math.floor((r.y1 + r.y2)/2);
      const x = r.x2+1; grid[y][x]=FLOOR;
    }
    if(r.ry<ROOM_ROWS-1){
      const x = Math.floor((r.x1 + r.x2)/2);
      const y = r.y2+1; grid[y][x]=FLOOR;
    }
  }

  const topRight = rooms.find(r=>r.rx===ROOM_COLS-1 && r.ry===0);
  const botLeft  = rooms.find(r=>r.rx===0 && r.ry===ROOM_ROWS-1);
  const botRight = rooms.find(r=>r.rx===ROOM_COLS-1 && r.ry===ROOM_ROWS-1);

  const startTile = { x: botRight.x2, y: botRight.y2 };

  // Puerta y c√°mara de salida (fuera del muro derecho de la sala sup. derecha)
  const doorY = Math.floor((topRight.y1 + topRight.y2)/2);
  const doorX = topRight.x2+1;
  for(let yy=doorY-1; yy<=doorY+1; yy++)
    for(let xx=doorX+1; xx<=doorX+3 && xx<grid[0].length; xx++)
      grid[yy][xx]=FLOOR;
  grid[doorY][doorX] = DOOR;
  const exitX = Math.min(doorX+3, grid[0].length-2);
  const exitY = doorY; grid[exitY][exitX] = EXIT;

  // Llave
  const keyX = botLeft.x1, keyY = botLeft.y2; grid[keyY][keyX] = KEY;

  return {grid, rooms, start:startTile, door:{x:doorX, y:doorY}, exit:{x:exitX, y:exitY}, key:{x:keyX,y:keyY}};
}

/* =========================
   Spawn de murci√©lagos (N por sala)
========================= */
function spawnBats(rooms, objects, grid){
  const bats = [];
  for(const r of rooms){
    let placed = 0, tries = 0;
    while(placed < BATS_PER_ROOM && tries < 2000){
      const x = randInt(r.x1, r.x2);
      const y = randInt(r.y1, r.y2);
      const occupied = (objects.start.x===x && objects.start.y===y) ||
                       (objects.key.x===x && objects.key.y===y) ||
                       (objects.door.x===x && objects.door.y===y) ||
                       (objects.exit.x===x && objects.exit.y===y) ||
                       bats.some(b=>b.x===x && b.y===y);
      if(grid[y][x]===FLOOR && !occupied){
        bats.push({x,y,rx:r.rx,ry:r.ry, room:r, alive:true, nextStep:0});
        placed++;
      }
      tries++;
    }
  }
  return bats;
}

/* =========================
   Estado + C√°mara (suavizado)
========================= */
const Game = {
  grid:null, rooms:null, width:0, height:0,
  player:{x:0,y:0, hasKey:false, hearts:MAX_HEARTS, facing:{dx:-1,dy:0}},
  bats:[],
  door:null, exit:null, key:null,
  state:STATE.PLAYING,
  timeLeft:TOTAL_TIME,
  safeUntil:0,
  torchReadyAt:0,
  qStats:{ total:0, ok:0, bad:0, byCat:{} },
  moving:false,
  fadeAlpha:0,
};

const Camera = {
  x:0, y:0, tx:0, ty:0,
  updateTargets(){
    const worldW = Game.width*TILE, worldH = Game.height*TILE;
    const halfW = canvas.width/2, halfH = canvas.height/2;
    const cx = Game.player.x*TILE + TILE/2, cy = Game.player.y*TILE + TILE/2;
    this.tx = clamp(cx, halfW, Math.max(halfW, worldW - halfW));
    this.ty = clamp(cy, halfH, Math.max(halfH, worldH - halfH));
  },
  step(dt){
    const smoothing = 1 - Math.pow(0.001, dt); // lerp exponencial
    this.x += (this.tx - this.x) * smoothing;
    this.y += (this.ty - this.y) * smoothing;
  }
};

function resetGame(){
  const {grid, rooms, start, door, exit, key} = buildMap();
  Game.grid=grid; Game.rooms=rooms; Game.width=grid[0].length; Game.height=grid.length;
  Game.player.x=start.x; Game.player.y=start.y; Game.player.hasKey=false; Game.player.hearts=MAX_HEARTS; Game.player.facing={dx:-1,dy:0};
  Game.door=door; Game.exit=exit; Game.key=key;
  Game.bats = spawnBats(rooms, {start, door, exit, key}, grid);
  Game.state=STATE.PLAYING; Game.timeLeft=TOTAL_TIME; Game.safeUntil=0; Game.torchReadyAt=0;
  Game.qStats = { total:0, ok:0, bad:0, byCat:{} }; Game.moving=false; Game.fadeAlpha=0;
  updateHUD(); hideVictory();
  Camera.updateTargets(); Camera.x = Camera.tx; Camera.y = Camera.ty;
}

/* =========================
   Canvas y render
========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  const hudH = document.getElementById('hud').offsetHeight || 72;
  canvas.width  = Math.max(640, Math.floor(window.innerWidth));
  canvas.height = Math.max(400, Math.floor(window.innerHeight - hudH));
}
window.addEventListener('resize', ()=>{ resizeCanvas(); Camera.updateTargets(); });

function worldToScreen(x,y){
  const px = Math.floor(x*TILE - (Camera.x - canvas.width/2));
  const py = Math.floor(y*TILE - (Camera.y - canvas.height/2));
  return {px,py};
}

function getFloorColor(x,y){ return ((x+y)%4===0) ? COLOR_FLOOR_A : COLOR_FLOOR_B; }
function getWallColor(){ return COLOR_WALL; }

function drawScene(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Rango visible
  const halfW = canvas.width/2, halfH = canvas.height/2;
  const left   = Math.floor((Camera.x - halfW)/TILE) - 2;
  const right  = Math.ceil((Camera.x + halfW)/TILE) + 2;
  const top    = Math.floor((Camera.y - halfH)/TILE) - 2;
  const bottom = Math.ceil((Camera.y + halfH)/TILE) + 2;

  for(let y=Math.max(0,top); y<=Math.min(Game.height-1,bottom); y++){
    for(let x=Math.max(0,left); x<=Math.min(Game.width-1,right); x++){
      const t = Game.grid[y][x];
      const s = worldToScreen(x,y);
      ctx.fillStyle = (t===WALL) ? getWallColor() : getFloorColor(x,y);
      ctx.fillRect(s.px, s.py, TILE, TILE);
    }
  }

  // Llave
  if(Game.grid[Game.key.y][Game.key.x]===KEY){ drawKey(Game.key.x, Game.key.y); }
  // Puerta / Salida
  if(Game.grid[Game.door.y][Game.door.x]===DOOR){ drawDoor(Game.door.x, Game.door.y, false); }
  drawExit(Game.exit.x, Game.exit.y);

  // Bats
  for(const b of Game.bats){ if(b.alive) drawBat(b); }
  // Jugador
  drawPlayer();

  // Overlay seguro por sala
  if(now()<Game.safeUntil){
    ctx.fillStyle = 'rgba(255, 243, 205, 0.22)';
    const r = currentRoomOf(Game.player.x, Game.player.y);
    if(r){
      const s = worldToScreen(r.x1, r.y1);
      ctx.fillRect(s.px, s.py, (r.x2-r.x1+1)*TILE, (r.y2-r.y1+1)*TILE);
    }
  }

  // Fundido de muerte
  if(Game.state===STATE.DEFEAT_HP || Game.state===STATE.DEFEAT_T){
    ctx.fillStyle = `rgba(0,0,0,${Game.fadeAlpha})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
}

/* =========================
   Sprites
========================= */
function drawKey(tx,ty){
  const s=worldToScreen(tx,ty); const x=s.px, y=s.py;
  ctx.fillStyle = '#f1c40f';
  ctx.fillRect(x+8, y+14, 16, 4);
  ctx.beginPath(); ctx.arc(x+24, y+16, 4, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#f39c12'; ctx.fillRect(x+18, y+12, 4, 4);
}
function drawDoor(tx,ty,open){
  const s=worldToScreen(tx,ty); const x=s.px, y=s.px? s.py : s.py; // segura
  ctx.fillStyle = open ? '#c7ecee' : '#d4a017';
  ctx.fillRect(x+2, y+2, TILE-4, TILE-4);
  if(!open){ ctx.fillStyle = '#8e5a0a'; ctx.fillRect(x+TILE/2-2, y+TILE/2-6, 4, 12); }
}
function drawExit(tx,ty){
  const s=worldToScreen(tx,ty); const x=s.px, y=s.py;
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x+6, y+6, TILE-12, TILE-12);
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x+10, y+10, TILE-20, TILE-20);
}
function drawBat(b){
  const s=worldToScreen(b.x,b.y); const x=s.px, y=s.py;
  const t = performance.now();
  const phase = Math.sin((t%BAT_WING_PERIOD)/BAT_WING_PERIOD * Math.PI*2);
  const wing = 6 + Math.floor(4*phase);
  ctx.fillStyle = "#2d3436";
  ctx.fillRect(x+12, y+12, 8, 8); // cuerpo
  ctx.beginPath(); // ala izq
  ctx.moveTo(x+12, y+16); ctx.lineTo(x+4, y+16-wing); ctx.lineTo(x+4, y+16+wing); ctx.closePath(); ctx.fill();
  ctx.beginPath(); // ala der
  ctx.moveTo(x+20, y+16); ctx.lineTo(x+28, y+16-wing); ctx.lineTo(x+28, y+16+wing); ctx.closePath(); ctx.fill();
}

/* =========================
   Personaje humanoide + ojos + paso
========================= */
function drawPlayer(){
  const s=worldToScreen(Game.player.x, Game.player.y); const x=s.px, y=s.py;
  const t = performance.now();
  const bob = Game.moving ? Math.sin(t/120)*1.5 : 0;

  // Tronco
  ctx.fillStyle = '#0c7bdc';
  ctx.fillRect(x+8, y+6 + bob, TILE-16, TILE-10);

  // Cabeza
  ctx.fillStyle = '#74b9ff';
  ctx.beginPath(); ctx.arc(x+TILE/2, y+8 + bob, 7, 0, Math.PI*2); ctx.fill();

  // Ojos
  const f = Game.player.facing; const eyeOffsetX = clamp(f.dx*2, -2, 2); const eyeOffsetY = clamp(f.dy*2, -2, 2);
  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(x+TILE/2 - 3, y+8 + bob, 2.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+TILE/2 + 3, y+8 + bob, 2.5, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(x+TILE/2 - 3 + eyeOffsetX*0.7, y+8 + eyeOffsetY*0.7 + bob, 1.3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+TILE/2 + 3 + eyeOffsetX*0.7, y+8 + eyeOffsetY*0.7 + bob, 1.3, 0, Math.PI*2); ctx.fill();

  // Brazos
  ctx.fillStyle = '#0b6fc5';
  ctx.fillRect(x+5,  y+10 + bob, 3, 8);
  ctx.fillRect(x+TILE-8, y+10 + bob, 3, 8);

  // Piernas
  const legSwing = Game.moving ? Math.sin(t/100)*2 : 0;
  ctx.fillStyle = '#084f8a';
  ctx.fillRect(x+10 + legSwing, y+TILE-12, 4, 10);
  ctx.fillRect(x+TILE-14 - legSwing, y+TILE-12, 4, 10);

  // Icono de llave
  if(Game.player.hasKey){
    ctx.fillStyle = '#f1c40f'; ctx.fillRect(x+TILE-12, y+TILE-12, 8, 4);
    ctx.fillStyle = '#f39c12'; ctx.fillRect(x+TILE-10, y+TILE-14, 4, 4);
  }
}

/* =========================
   Entrada / movimiento
========================= */
const keys = new Set();
let lastMoveTime=0;
const MOVE_DELAY = 0.08;

document.addEventListener('keydown', (e)=>{
  if(Game.state===STATE.ASKING) return;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD','KeyF'].includes(e.code)) e.preventDefault();
  if(!AudioSys.ctx) AudioSys.ensure();
  keys.add(e.code);
  handleInstantKeys(e.code);
});
document.addEventListener('keyup', (e)=>{ keys.delete(e.code); });

function handleInstantKeys(code){
  if(Game.state!==STATE.PLAYING) return;
  if(code==='KeyF') useTorch();
}

function updateInput(){
  if(Game.state!==STATE.PLAYING) return;
  const t=now();
  if(t-lastMoveTime<MOVE_DELAY){ Game.moving=false; return; }
  let dx=0, dy=0;
  if(keys.has('ArrowUp')||keys.has('KeyW')) dy=-1;
  else if(keys.has('ArrowDown')||keys.has('KeyS')) dy=1;
  else if(keys.has('ArrowLeft')||keys.has('KeyA')) dx=-1;
  else if(keys.has('ArrowRight')||keys.has('KeyD')) dx=1;

  if(dx||dy){
    Game.player.facing = {dx,dy};
    tryMove(dx,dy);
    lastMoveTime=t;
    Game.moving=true;
  } else {
    Game.moving=false;
  }
}

function inBounds(x,y){ return y>=0 && y<Game.height && x>=0 && x<Game.width; }
function isWall(x,y){ return Game.grid[y][x]===WALL; }
function isDoor(x,y){ return Game.grid[y][x]===DOOR; }
function isExit(x,y){ return Game.grid[y][x]===EXIT; }
function isKey(x,y){ return Game.grid[y][x]===KEY; }

function currentRoomOf(x,y){ return Game.rooms.find(r=>x>=r.x1 && x<=r.x2 && y>=r.y1 && y<=r.y2); }

function tryMove(dx,dy){
  const nx = Game.player.x+dx;
  const ny = Game.player.y+dy;
  if(!inBounds(nx,ny)) return;
  if(isWall(nx,ny)) return;

  // Puerta: bloquea si no tiene llave
  if(isDoor(nx,ny) && !Game.player.hasKey){
    setStatus("La puerta est√° cerrada. Necesitas la llave.");
    return;
  }
  // Abrir puerta si tiene llave
  if(isDoor(nx,ny) && Game.player.hasKey){
    Game.grid[Game.door.y][Game.door.x]=FLOOR;
    AudioSys.beep('door');
  }

  Game.player.x=nx; Game.player.y=ny;

  // Recoger llave
  if(isKey(nx,ny)){
    Game.player.hasKey=true;
    Game.grid[Game.key.y][Game.key.x]=FLOOR;
    AudioSys.beep('key');
    setStatus("Llave dorada obtenida.");
  }

  // Salida: SOLO con llave
  if(isExit(nx,ny)){
    if(Game.player.hasKey){
      Game.state=STATE.VICTORY;
      showVictory();
      return;
    } else {
      setStatus("Para salir, primero abre la puerta con la llave.");
    }
  }

  // Colisi√≥n con murci√©lagos (si no hay 'seguro')
  if(now()>Game.safeUntil){
    const bat = Game.bats.find(b=>b.alive && b.x===nx && b.y===ny);
    if(bat){ bat.alive=false; launchQuiz(7); }
  }

  Camera.updateTargets(); // actualizar destino de c√°mara
}

/* =========================
   Antorcha
========================= */
function useTorch(){
  const t=now();
  if(t < Game.torchReadyAt) return;
  Game.safeUntil = t + TORCH_SAFE;
  Game.torchReadyAt = t + TORCH_CD;
  const r = currentRoomOf(Game.player.x, Game.player.y);
  if(r){ for(const b of Game.bats){ if(b.alive && b.rx===r.rx && b.ry===r.ry){ b.alive=false; } } }
  setStatus("Sala despejada. Seguridad 5 s.");
  updateHUD();
}

/* =========================
   AI Murci√©lagos
========================= */
function updateBats(){
  if(Game.state!==STATE.PLAYING) return;
  const t = performance.now();
  for(const b of Game.bats){
    if(!b.alive) continue;
    if(!b.nextStep || t>=b.nextStep){
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      shuffle(dirs);
      for(const [dx,dy] of dirs){
        const nx=b.x+dx, ny=b.y+dy;
        if(nx>=b.room.x1 && nx<=b.room.x2 && ny>=b.room.y1 && ny<=b.room.y2 && Game.grid[ny][nx]!==WALL){
          b.x=nx; b.y=ny; break;
        }
      }
      const interval = (BAT_STEP_MIN + Math.random()*(BAT_STEP_MAX-BAT_STEP_MIN))*1000;
      b.nextStep = t + interval;
    }
  }
  // Colisi√≥n si pisan al jugador
  if(now()>Game.safeUntil){
    const hit = Game.bats.find(b=>b.alive && b.x===Game.player.x && b.y===Game.player.y);
    if(hit){ hit.alive=false; launchQuiz(7); }
  }
}

/* =========================
   HUD
========================= */
const heartsDiv = document.getElementById('hearts');
const timerDiv = document.getElementById('timer');
const torchFill = document.getElementById('torchFill');
const torchPct = document.getElementById('torchPct');
const statusBubble = document.getElementById('statusBubble');

function setStatus(msg){ statusBubble.textContent = msg; setTimeout(()=>{ if(statusBubble.textContent===msg) statusBubble.textContent=''; }, 3000); }

function updateHUD(){
  heartsDiv.innerHTML = '';
  for(let i=0;i<MAX_HEARTS;i++){
    const d=document.createElement('div');
    d.className = 'heart'+(i<Game.player.hearts?'':' empty');
    heartsDiv.appendChild(d);
  }
  timerDiv.textContent = '‚è≥ '+fmtTime(Game.timeLeft);
  const t=now();
  const pct = clamp( (TORCH_CD - (Game.torchReadyAt - t)) / TORCH_CD, 0, 1 );
  torchFill.style.width = (pct*100).toFixed(0)+'%';
  torchPct.textContent = (pct*100).toFixed(0)+'%';
}

/* =========================
   Preguntas (STEM)
========================= */
const quizModal = document.getElementById('quizModal');
const qText = document.getElementById('qText');
const qMeta = document.getElementById('qMeta');
const qButtons = Array.from(document.querySelectorAll('.optBtn'));
const qProgress = document.getElementById('qProgress');
const qCount = document.getElementById('quizCount');

let quizQueue = [];
let quizIdx = 0;

function pickQuestion(){ return QUESTION_BANK[randInt(0, QUESTION_BANK.length-1)]; }

function launchQuiz(n){
  Game.state = STATE.ASKING;
  quizQueue = []; quizIdx = 0;
  for(let i=0;i<n;i++) quizQueue.push(pickQuestion());
  qProgress.innerHTML=''; for(let i=0;i<n;i++){ const seg=document.createElement('div'); seg.className='seg'; qProgress.appendChild(seg); }
  qCount.textContent = `Pregunta 1 de ${n}`;
  showQuestion();
  showModal(true);
}

function showModal(on){ quizModal.style.display = on?'flex':'none'; }

function showQuestion(){
  const q = quizQueue[quizIdx];
  qText.textContent = q.text;
  qMeta.textContent = `Categor√≠a: ${q.cat}`;
  qButtons.forEach((btn,i)=>{ btn.querySelector('.optTxt').textContent = q.opts[i]; });
}

qButtons.forEach(btn=> btn.addEventListener('click', ()=> handleAnswer(Number(btn.dataset.idx)) ));
document.addEventListener('keydown', (e)=>{
  if(Game.state===STATE.ASKING && ['Digit1','Digit2','Digit3','Digit4'].includes(e.code)){
    e.preventDefault(); handleAnswer(Number(e.code.replace('Digit',''))-1);
  }
});

function startDeathFade(stateType){ Game.state = stateType; Game.fadeAlpha = 0; }

function handleAnswer(idx){
  const q = quizQueue[quizIdx];
  const ok = (idx===q.correct);
  const seg = qProgress.children[quizIdx];
  seg.classList.add(ok?'on':'bad');

  if(ok){ AudioSys.beep('ok'); Game.qStats.ok++; }
  else {
    AudioSys.beep('bad');
    Game.player.hearts = Math.max(0, Game.player.hearts-1);
    Game.qStats.bad++;
    if(Game.player.hearts===0){ showModal(false); startDeathFade(STATE.DEFEAT_HP); return; }
    updateHUD();
  }

  Game.qStats.total++;
  Game.qStats.byCat[q.cat] ??= {total:0, ok:0, bad:0};
  Game.qStats.byCat[q.cat].total++; if(ok) Game.qStats.byCat[q.cat].ok++; else Game.qStats.byCat[q.cat].bad++;

  quizIdx++;
  if(quizIdx>=quizQueue.length){ showModal(false); Game.state=STATE.PLAYING; }
  else { qCount.textContent = `Pregunta ${quizIdx+1} de ${quizQueue.length}`; showQuestion(); }
}

/* =========================
   Victoria / Resultados
========================= */
const victory = document.getElementById('victory');
const btnReiniciar = document.getElementById('btnReiniciar');
btnReiniciar.addEventListener('click', ()=>{ victory.style.display='none'; resetGame(); });

function showVictory(){
  const v = document.getElementById('victStats');
  const total = Game.qStats.total, ok = Game.qStats.ok, bad = Game.qStats.bad;
  const acc = total? Math.round(100*ok/total):0;
  v.innerHTML = `<p><strong>Tiempo restante:</strong> ${fmtTime(Game.timeLeft)} ‚Ä¢ <strong>HP:</strong> ${Game.player.hearts}/${MAX_HEARTS}</p>
                 <p><strong>Preguntas:</strong> ${total} &nbsp;|&nbsp; <strong>Correctas:</strong> ${ok} &nbsp;|&nbsp; <strong>Incorrectas:</strong> ${bad} &nbsp;|&nbsp; <strong>Acierto:</strong> ${acc}%</p>`;
  const tbody = document.querySelector('#catTable tbody');
  tbody.innerHTML='';
  for(const [cat, s] of Object.entries(Game.qStats.byCat)){
    const a = s.total? Math.round(100*s.ok/s.total):0;
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${cat}</td><td>${s.total}</td><td>${s.ok}</td><td>${s.bad||0}</td><td>${a}%</td>`;
    tbody.appendChild(tr);
  }
  victory.style.display='flex';
}
function hideVictory(){ victory.style.display='none'; }

/* =========================
   Bucle
========================= */
let lastTime = performance.now()/1000;

function gameLoop(){
  requestAnimationFrame(gameLoop);
  const t=now();
  const dt = t-lastTime;
  lastTime=t;

  if(Game.state===STATE.PLAYING){
    Game.timeLeft -= dt;
    if(Game.timeLeft<=0){ startDeathFade(STATE.DEFEAT_T); }
    else { updateInput(); updateBats(); }
  } else if(Game.state===STATE.DEFEAT_HP || Game.state===STATE.DEFEAT_T){
    Game.fadeAlpha = Math.min(1, Game.fadeAlpha + dt/1.0);
    if(Game.fadeAlpha>=1){ resetGame(); return; }
  }

  updateHUD();
  Camera.updateTargets();
  Camera.step(dt);
  drawScene();
}

resetGame();
resizeCanvas();
gameLoop();

window.addEventListener('load', ()=>document.getElementById('game').focus());
document.getElementById('canvasWrap').addEventListener('click', ()=>document.getElementById('game').focus());
</script>
</body>
</html>
